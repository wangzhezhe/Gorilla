
#ifndef TRIGGERMANAGER_H
#define TRIGGERMANAGER_H

// store the registered triggers

#include <map>
#include <set>
#include <queue>
#include <string>
#include <thallium.hpp>
#include <vector>
#include "../../commondata/metadata.h"
#include "../../utils/ArgothreadPool.h"
#include "../../client/unimosclient.h"
#include "../FunctionManager/functionManagerMeta.h"
#include "../MetadataManager/metadataManager.h"

namespace tl = thallium;

struct DynamicTriggerManager
{
    DynamicTriggerManager( 
        size_t poolSize,
        MetaDataManager* metadataManager,
        UniClient* uniclient): m_metadataManager(metadataManager),m_uniclient(uniclient)
    {
        this->m_threadPool = new ArgoThreadPool(poolSize);
    };

    void updateTrigger(std::string triggerName, DynamicTriggerInfo triggerInfo){
        m_dynamicTrigger[triggerName] = triggerInfo;
    };

    void initstart(std::string triggerName, size_t step, std::string varName, RawDataEndpoint rde);

    void commonstart(std::string triggerName, size_t step, std::string varName, RawDataEndpoint rde);

    void putEvent(std::string varName, EventWrapper &event);

    EventWrapper getEvent(std::string varName);

    //void removeTrigger(std::string triggerName);

    //put the trigger into the manager
    //from the trigger name to the trigger instance
    std::map<std::string, DynamicTriggerInfo> m_dynamicTrigger;
    
    //the key is the name of the trigger, the value is the event generated by this trigger
    tl::mutex m_eventMapQueueMutex;
    std::map<std::string, std::queue<EventWrapper>> eventMapQueue;


    //from the triggerName to the watcher
    //TODO, the collective operation is necessary here, only sent the request back
    //when all notifier send notify info
    tl::mutex m_watcherSetMutex;
    std::set<std::string> m_registeredWatcherSet;

    //the place that store the function
    FunctionManagerMeta* m_funcmanagerMeta = nullptr;

    //the function manager may need to send request to specific server
    //it needs to hold a pointer to the client
    UniClient* m_uniclient = nullptr; 

    //hold the pointer to the metadataManager
    MetaDataManager * m_metadataManager = nullptr;

    ArgoThreadPool* m_threadPool = nullptr;

    ~DynamicTriggerManager()
    {
        if (this->m_threadPool != nullptr)
        {
            delete this->m_threadPool;
        }
    };
};



#endif