

Al,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
At,1.70434,1.70744,1.70726,1.70594,1.7028,1.70593,1.70844,1.17001,1.13878,1.09853,1.04686,0.99512,0.929459,0.85362,0.757515,0.640016,0.486286,0.284189,0.0683296,0.0675235,0.0681865,0.068398,0.0675328,0.0681319,0.067627,0.0681436,0.0674758,0.0675857,0.0682137,0.068068,0.0682251,0.0682065,0.06739,0.0681574,0.0681896,0.068295,0.0683513,0.0685616,0.0685863,0.0681984,0.0672603,0.0681841,0.068552,0.282603,0.48574,0.639529,0.756489,0.854324,0.930507,0.995445,1.05028,1.09701,1.13657,1.17121,1.70553,1.70887,1.71021,1.70705,1.70744,1.70382
S,0.852789,0.861599,0.859603,0.860263,0.86123,0.861238,0.861407,0.861264,0.860995,0.860949,0.861847,0.861555,0.8598,0.860926,0.861523,0.861662,0.861226,0.861428,0.86189,0.860556,0.860517,0.860366,0.861563,0.86143,0.861635,0.860639,0.861355,0.857414,0.858593,0.8604,0.865389,0.861633,0.861439,0.859209,0.860726,0.859805,0.865708,0.860367,0.860728,0.860394,0.86083,0.860578,0.858307,0.859277,0.860698,0.860658,0.86495,0.865549,0.864925,0.86429,0.86496,0.865735,0.868574,0.866102,0.864916,0.859392,0.860108,0.859928,0.860235,0.860035
W,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0


0: sim executiontime 94.441

void vhlh(int step, int totalStep)
{
  int workLoadhigh = 1500;
  int workLoadlow = 60;
  int workLoad = 0;

  // 0-bound1 steady
  int bound1 = (totalStep / 5) - 6;
  // bound1-bound2 increase
  int bound2 = (2 * totalStep / 5) - 6;
  // bound2-bound3 steady
  int bound3 = (3 * totalStep / 5) + 6;
  // bound2-bound4 decrease
  int bound4 = (4 * totalStep / 5) + 6;
  // bound4-last steady

  // 0.2 is a good value to make sure it increase gradually
  // try this later
  double rate = 0.2;

  if (step < (bound1))
  {
    workLoad = workLoadhigh;
    // first part
  }
  else if (step > bound1 && step < bound2)
  {
    workLoad = workLoadhigh - workLoadhigh * (1.0 / (1.0 + rate * (bound2 - step)));
  }
  else if (step >= bound2 && step <= bound3)
  {
    workLoad = workLoadlow;
  }
  else if (step > bound3 && step < bound4)
  {
    workLoad = workLoadhigh - workLoadhigh * (1.0 / (1.0 + rate * (step - bound3)));
  }
  else
  {
    // last part
    workLoad = workLoadhigh;
  }

  int num = 500;
  std::vector<double> v(num, 0);
  double results = 0;
  for (int i = 0; i < workLoad; i++)
  {
    for (int j = 0; j < num; j++)
    {
      double rf = (double)rand() / RAND_MAX;
      v[j] = 0 + rf * (0.1 * i - 0);
    }
    for (int j = 0; j < num; j++)
    {
      results = v[j] + results;
    }
    std::this_thread::sleep_for(1ms);
  }
  return;
}